import os
import re
import shutil
from typing import Dict, List, Set
from scripts.core.cache import load_cache
from scripts.core.constants import CACHE_DIR
from scripts.core.version import Version
from scripts.core.language import Translate
from scripts.utils import echo
from scripts.tiles.entity_infobox import generate_merged_entity_infoboxes
from scripts.tiles.tiles_stitcher import stitch_entity_sprites_for_lang


def extract_base_name(entity_name: str) -> str:
    """
    Extract the base name from an entity name by removing level suffix.

    Args:
        entity_name (str): Full entity name (e.g., "Wood_BarElementCorner_Lvl1" or "WoodenWallLvl1")

    Returns:
        str: Base name without level suffix (e.g., "Wood_BarElementCorner" or "WoodenWall")
    """
    # Remove _LvlX, _Lvl_X, LvlX, or Lvl_X patterns (underscore before Lvl is optional)
    base_name = re.sub(r"_?Lvl_?\d+$", "", entity_name, flags=re.IGNORECASE)
    return base_name


def group_entities_by_base(entity_data: Dict[str, dict]) -> Dict[str, List[tuple]]:
    """
    Group entities by their base name, sorting level variants together.

    Args:
        entity_data (Dict[str, dict]): Dictionary of all entity definitions

    Returns:
        Dict[str, List[tuple]]: Dictionary mapping base names to list of (entity_name, entity_def) tuples
    """
    grouped: Dict[str, List[tuple]] = {}

    for entity_name, entity_def in entity_data.items():
        # Skip entities starting with ES_
        if entity_name.startswith("ES_"):
            continue

        base_name = extract_base_name(entity_name)

        if base_name not in grouped:
            grouped[base_name] = []

        grouped[base_name].append((entity_name, entity_def))

    # Sort each group by level number
    for base_name in grouped:
        grouped[base_name].sort(key=lambda x: x[0])  # Sort by entity name

    return grouped


def create_header(
    base_name: str, entity_variants: List[tuple], game_version: str
) -> str:
    """
    Create the header markup for an entity article.

    Args:
        base_name (str): Base name of the entity (without level suffix).
        entity_variants (List[tuple]): List of (entity_name, entity_def) tuples for all level variants.
        game_version (str): Current game version.

    Returns:
        str: Header markup with metadata templates.
    """
    header = (
        f"{{{{Navbar furniture}}}}\n"
        f"{{{{Page version|{game_version}}}}}\n"
        f"{{{{Autogenerated|B42 tiles}}}}"
    )

    return header


def create_infobox(
    base_name: str, entity_variants: List[tuple], infoboxes: Dict[str, str]
) -> str:
    """
    Get the infobox for an entity from the generated infoboxes.

    Args:
        base_name (str): Base name of the entity (without level suffix).
        entity_variants (List[tuple]): List of (entity_name, entity_def) tuples for all level variants.
        infoboxes (Dict[str, str]): Dictionary mapping base names to merged infobox markup.

    Returns:
        str: Infobox markup.
    """
    infobox = infoboxes.get(base_name, "")
    return infobox


def create_intro(base_name: str, entity_variants: List[tuple]) -> str:
    """
    Create the introduction paragraph for an entity article.

    Args:
        base_name (str): Base name of the entity (without level suffix).
        entity_variants (List[tuple]): List of (entity_name, entity_def) tuples for all level variants.

    Returns:
        str: Introduction paragraph.
    """
    # Use the first variant to get display name, then remove level descriptor
    first_entity_name, first_entity_def = entity_variants[0]

    # Get display name from outputs
    outputs = first_entity_def.get("outputs", [])
    if outputs and len(outputs) > 0:
        display_name_key = outputs[0].get("displayName", "")
        translated = Translate.get(display_name_key, "DisplayName")
        if translated and translated != display_name_key:
            display_name = translated
        else:
            display_name = display_name_key
    else:
        display_name = base_name

    # Remove level descriptors like "(Shoddy)", "(Sturdy)", "(Solid)" from display name
    display_name = re.sub(r"\s*\([^)]+\)\s*$", "", display_name)

    # Determine article (a/an)
    first_char = display_name[0].lower() if display_name else "a"
    article = "An" if first_char in "aeiou" else "A"

    intro = f"{article} '''{display_name.lower()}''' is a buildable [[furniture|tile]]."

    return intro


def create_usage(base_name: str, entity_variants: List[tuple]) -> str:
    """
    Create the usage section for an entity article.

    Args:
        base_name (str): Base name of the entity (without level suffix).
        entity_variants (List[tuple]): List of (entity_name, entity_def) tuples for all level variants.

    Returns:
        str: Usage section markup.
    """
    return f"== Usage ==\nHelp PZwiki by adding to this section. {{{{Edit link}}}}"


def create_crafting(base_name: str, entity_variants: List[tuple]) -> str:
    """
    Create the crafting section for an entity article.

    Args:
        base_name (str): Base name of the entity (without level suffix).
        entity_variants (List[tuple]): List of (entity_name, entity_def) tuples for all level variants.

    Returns:
        str: Crafting section markup.
    """
    crafting_parts = []
    crafting_parts.append("== Obtaining ==")
    crafting_parts.append("{{Crafting/sandbox")

    # Add each level variant as a recipe line
    for entity_name, _ in entity_variants:
        crafting_parts.append(f"|{entity_name}")

    crafting_parts.append("}}")

    crafting = "\n".join(crafting_parts)
    return crafting


def create_navigation() -> str:
    """
    Create the navigation section for an entity article.

    Returns:
        str: Navigation section markup.
    """
    navigation = "== Navigation ==\n{{Navbox construction}}"
    return navigation


def collect_entity_sprites(grouped_entities: Dict[str, List[tuple]]) -> Set[str]:
    """
    Collect all unique sprite names from all entities, including composite names.

    Args:
        grouped_entities (Dict[str, List[tuple]]): Dictionary mapping base names to entity variants.

    Returns:
        Set[str]: Set of unique sprite names used by entities (both individual and composite).
    """
    sprites: Set[str] = set()

    for base_name, entity_variants in grouped_entities.items():
        for entity_name, entity_def in entity_variants:
            sprite_outputs = entity_def.get("spriteOutputs", {})
            for facing, sprite_list in sprite_outputs.items():
                if sprite_list:
                    # Filter out non-string values (e.g., False, None) and add individual sprites
                    valid_sprites = [s for s in sprite_list if s and isinstance(s, str)]
                    sprites.update(valid_sprites)
                    # Add composite name if multi-sprite
                    if len(valid_sprites) > 1:
                        composite_name = "+".join(valid_sprites)
                        sprites.add(composite_name)

    return sprites


def copy_entity_sprites(
    sprites: Set[str], lang_code: str, source_dir: str = "resources/tile_images"
) -> None:
    """
    Copy sprite images from source directory to output directory.
    Also copies stitched composite sprites from the entity_images_stitched directories.

    Args:
        sprites (Set[str]): Set of sprite names to copy (including composite names).
        lang_code (str): Language code for output directory.
        source_dir (str): Source directory containing individual sprite images.
    """
    output_dir = os.path.join("output", lang_code, "tiles", "entity_images")
    os.makedirs(output_dir, exist_ok=True)

    # Stitched entity sprites are in output/{lang_code}/tiles/entity_images_stitched/{facing}/
    stitched_base_dir = os.path.join(
        "output", lang_code, "tiles", "entity_images_stitched"
    )
    stitched_facing_dirs = ["South", "East", "North", "West"]

    copied_count = 0
    missing_count = 0

    for sprite in sprites:
        sprite_filename = f"{sprite}.png"
        output_path = os.path.join(output_dir, sprite_filename)

        # First, try to find in the source directory (individual sprites)
        source_path = os.path.join(source_dir, sprite_filename)

        if os.path.exists(source_path):
            try:
                shutil.copy2(source_path, output_path)
                copied_count += 1
                continue
            except Exception as exc:
                echo.error(f"Failed to copy {sprite_filename}: {exc}")
                continue

        # If not found, try stitched directories (composite sprites)
        found_stitched = False
        for facing_dir in stitched_facing_dirs:
            stitched_path = os.path.join(stitched_base_dir, facing_dir, sprite_filename)
            if os.path.exists(stitched_path):
                try:
                    shutil.copy2(stitched_path, output_path)
                    copied_count += 1
                    found_stitched = True
                    break
                except Exception as exc:
                    echo.error(f"Failed to copy stitched {sprite_filename}: {exc}")

        if not found_stitched and not os.path.exists(source_path):
            missing_count += 1


def assemble_article(
    header: str,
    infobox: str,
    intro: str,
    usage: str,
    crafting: str,
    navigation: str,
) -> str:
    """
    Combine all article sections into a complete wiki article.

    Args:
        header (str): Article header with metadata templates.
        infobox (str): Infobox template markup.
        intro (str): Article introduction paragraph.
        usage (str): Usage section markup.
        crafting (str): Crafting section markup.
        navigation (str): Navigation template markup.

    Returns:
        str: Complete wiki article text with all sections properly formatted.
    """
    article_parts = []

    if header and header.strip():
        article_parts.append(header)
    if infobox and infobox.strip():
        article_parts.append(infobox)

    article = "\n".join(article_parts)

    if intro and intro.strip():
        if article:
            article += "\n" + intro
        else:
            article = intro

    remaining_sections = [usage, crafting, navigation]
    for section in remaining_sections:
        if section and section.strip():
            if article:
                article += "\n\n" + section
            else:
                article = section

    return article


def generate_entity_articles(
    grouped_entities: Dict[str, List[tuple]],
    infoboxes: Dict[str, str],
    lang_code: str,
    game_version: str,
):
    """
    Generate and save wiki articles for all entities.

    Args:
        grouped_entities (Dict[str, List[tuple]]): Dictionary mapping base names to list of (entity_name, entity_def) tuples.
        infoboxes (Dict[str, str]): Dictionary mapping base names to their merged infobox markup.
        lang_code (str): Language code for output directory.
        game_version (str): Current game version.

    The function generates complete wiki articles by combining various components
    and saves them to individual files in the output directory structure.
    Each article includes metadata, infobox, introduction, usage information,
    crafting recipes, code snippets, and navigation elements.
    """

    output_directory = os.path.join("output", lang_code, "tiles", "entity_articles")
    os.makedirs(output_directory, exist_ok=True)

    articles: Dict[str, str] = {}

    for idx, (base_name, entity_variants) in enumerate(grouped_entities.items(), 1):
        # Skip entities starting with ES_
        if base_name.startswith("ES_"):
            continue

        try:
            # Generate each section
            header = create_header(base_name, entity_variants, game_version)
            infobox = create_infobox(base_name, entity_variants, infoboxes)
            intro = create_intro(base_name, entity_variants)
            usage = create_usage(base_name, entity_variants)
            crafting = create_crafting(base_name, entity_variants)
            navigation = create_navigation()

            # Assemble the complete article
            article = assemble_article(
                header, infobox, intro, usage, crafting, navigation
            )

            articles[base_name] = article

            # Write to file
            filename = base_name.replace(" ", "_") + ".txt"
            output_path = os.path.join(output_directory, filename)
            with open(output_path, "w", encoding="utf-8") as fh:
                fh.write(article)

        except Exception as exc:
            echo.error(f"Failed to generate article for '{base_name}': {exc}")

    return articles


def main(lang_code: str, entity_data: Dict[str, dict] = None):
    """
    Main execution function for entity article generation.

    Args:
        lang_code (str): Language code to process
        entity_data (Dict[str, dict], optional): Pre-loaded entity data. If None, loads from cache.

    This function:
    1. Loads the parsed entity data cache (if not provided)
    2. Groups entities by base name (merging level variants)
    3. Generates merged entity infoboxes
    4. Generates complete entity articles
    5. Outputs files to output/{lang_code}/tiles/entity_articles/
    """

    game_version = Version.get()

    # Load entity data if not provided
    if entity_data is None:
        ENTITY_CACHE_FILE = "parsed_entity_data.json"
        entity_path = os.path.join(CACHE_DIR, ENTITY_CACHE_FILE)

        try:
            entity_data = load_cache(entity_path, "Entity")

        except Exception as exc:
            echo.error(f"Failed to load entity cache: {exc}")
            echo.error(
                "Make sure the entity cache exists by running the script parser first"
            )
            return

    if not entity_data:
        echo.error("Entity data is empty, skipping generation")
        return

    # Group entities by base name (merge level variants)
    grouped_entities = group_entities_by_base(entity_data)

    # generate merged infoboxes
    echo.info("Generating entity infoboxes")
    infoboxes = generate_merged_entity_infoboxes(
        grouped_entities, lang_code, game_version
    )
    echo.success(f"Entity infoboxes generated ({len(infoboxes)} base entities)")

    # generate complete articles
    echo.info("Generating entity articles")
    articles = generate_entity_articles(
        grouped_entities, infoboxes, lang_code, game_version
    )
    echo.success(f"Entity articles generated ({len(articles)} base entities)")

    # Stitch multi-sprite entities before copying
    echo.info("Stitching multi-sprite entity tiles")
    try:
        stitch_entity_sprites_for_lang(lang_code)
        echo.success("Entity sprite stitching completed")
    except Exception as exc:
        echo.warning(f"Entity sprite stitching failed: {exc}")

    # copy sprite images
    echo.info("Collecting and copying entity sprite images")
    sprites = collect_entity_sprites(grouped_entities)
    copy_entity_sprites(sprites, lang_code)
    echo.success(f"Entity sprites copied ({len(sprites)} unique sprites)")
