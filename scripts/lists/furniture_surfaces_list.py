import os, re
from scripts.core.constants import DATA_DIR
from scripts.core.version import Version
from scripts.core.language import Language
from scripts.core.cache import load_cache
from scripts.utils import echo
from scripts.tiles.tiles_infobox import extract_tile_stats
from scripts.core.page_manager import init as init_pages, get_pages

MOVABLE_DEFINITIONS_CACHE_FILE = "movable_definitions.json"

SURFACES_TABLE_HEADER = """{| class="wikitable theme-red sortable" style="text-align: center;"
|-
! class="unsortable" | Object
! class="sortable" | Encumbrance
! class="sortable" | Size<br>(tiles)
! class="unsortable" | Crafting surface?
"""

def _is_blacklisted(tile: dict) -> bool:
    # reuse the furniture_list blacklist
    from scripts.lists.furniture_list import BLACKLIST
    sprite    = tile.get('sprite','').lower()
    tile_type = tile.get('type','').lower()
    generic   = tile.get('properties',{}).get('generic',{})
    custom    = str(generic.get('CustomName','')).lower()
    group     = str(generic.get('GroupName','')).lower()

    forbidden_sprites = [s.lower() for s in BLACKLIST.get('sprite',[])]
    forbidden_types   = {t.lower() for t in BLACKLIST.get('type',[])}
    forbidden_customs = {c.lower() for c in BLACKLIST.get('CustomName',[])}
    forbidden_groups  = {g.lower() for g in BLACKLIST.get('GroupName',[])}

    for fs in forbidden_sprites:
        if sprite == fs or sprite.startswith(fs + '_'):
            return True
    if tile_type in forbidden_types:
        return True
    if custom in forbidden_customs:
        return True
    if group in forbidden_groups:
        return True
    return False

def _flatten_with_parent(named_tiles_data: dict):
    reps = []
    sprite_map = {}
    for group_name, variants in named_tiles_data.items():
        if isinstance(variants, dict) and variants:
            first = next(iter(variants.values()))
            reps.append(first)
            sprite_map[first["sprite"]] = group_name
    return reps, sprite_map

def _parse_grid(grid_string: str):
    try:
        row, col = map(int, grid_string.split(","))
        return col, row
    except Exception:
        return 0, 0

def generate_surface_list(named_tiles_data: dict):
    init_pages()

    # load definitions cache for encumbrance/size
    definitions_data, _ = load_cache(
        os.path.join(DATA_DIR, MOVABLE_DEFINITIONS_CACHE_FILE),
        "Movable Definitions",
        get_version=True
    )

    reps, sprite_map = _flatten_with_parent(named_tiles_data)

    # skip blacklisted
    surfaces = [
        t for t in reps
        if str(t.get("properties", {})
                  .get("generic", {})
                  .get("GenericCraftingSurface", "")
               ).lower() == "true"
           and not _is_blacklisted(t)
    ]

    current_version  = Version.get()
    current_language = Language.get()

    output_dir = os.path.join(os.getcwd(), "output", current_language, "tiles")
    os.makedirs(output_dir, exist_ok=True)

    header = (
        "{{Header|Project Zomboid|Tiles}}\n"
        f"{{{{Page version|{current_version}}}}}\n"
        "{{toc|right}}\n"
        "{{Autogenerated}}\n"
        "==Overview==\n"
        "The following list contains every [[furniture]] tile with the 'GenericCraftingSurface' "
        "flag, allowing it to be used as a surface in crafting recipes.\n\n"
        "Examples of non-furniture crafting surfaces include large stones an boulders.\n\n"
        "==Surfaces==\n"
    )

    text = header
    text += SURFACES_TABLE_HEADER

    # for each surface, output only the 4 columns
    for tile_data in surfaces:
        rep = tile_data["sprite"]
        group = sprite_map.get(rep)
        page_name = group or rep

        # variant naming
        vm = re.match(r'^(?P<b>.*)_(?P<n>\d{1,3}|1000)$', page_name)
        if vm:
            page_name = f"{vm.group('b')} (variant {vm.group('n')})"

        # stats
        tile_group = named_tiles_data.get(group, {}) or {}
        enc, size, _, _, _, _ = extract_tile_stats(
            tile_group, definitions_data, current_language
        )

        # pick best sprite
        candidates = []
        for key, var in tile_group.items():
            gen = var.get("properties", {}).get("generic", {})
            pos = _parse_grid(gen.get("SpriteGridPos", "0,0"))
            facing = gen.get("Facing")
            candidates.append((key, pos, facing))

        south = [(k,p) for k,p,f in candidates if f=="S"]
        east  = [(k,p) for k,p,f in candidates if f=="E"]
        sel   = south or east or [(k,p) for k,p,_ in candidates]
        sel.sort(key=lambda x: (x[1][1], x[1][0]))
        order = [k for k,_ in sel]

        # lookup wiki page by sprite ID
        found = None
        for vk in order:
            try:
                pages = get_pages(vk, id_type="sprite_id")
            except KeyError:
                pages = None
            if pages:
                found = pages[0]
                break

        if found:
            page_link = f"[[{found}|{page_name}]]"
            img_ref    = found
        else:
            page_link = f"[[{page_name}]]"
            img_ref    = page_name

        # build file
        if size >= 2 and len(order) >= 2:
            first_key = order[0]
            suffixes = [key.rsplit("_", 1)[-1] for key in order[1:]]
            file_stem = first_key + "".join("+" + s for s in suffixes)
        else:
            file_stem = order[0] if order else rep

        file_link = f"[[File:{file_stem}.png|link={img_ref}]]"

        text += "|-\n"
        text += f"| {file_link}<br>{page_link}\n"
        text += f"| {enc}\n"
        text += f"| {size}\n"
        text += "| [[File:UI Tick.png|link=|Can be used as a surface]]\n"

    text += "|}\n"

    out_file = os.path.join(output_dir, "furniture_surfaces_list.txt")
    try:
        with open(out_file, "w", encoding="utf-8") as f:
            f.write(text)
    except Exception as err:
        echo.error(f"Failed writing 'furniture_surfaces_list': {err}")
